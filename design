RubyReportable.define :case_management_roster do
  source :as => :client_application do
    ClientApplication.joins(:assigned_worker, :client)
  end

  output('CLTC #')         { client_application.client.cltc_number }
  output('Program')        { client_application.program.to_s }
  output('Worker')         { client_application.assigned_worker.to_s }
  output('Level of Care')  { client_application.latest_assessment.care_level.to_s }

  filter('Worker') do
    key :worker
    on :source

    require do
      meta[:current_user].roles.include?(:all)
    end

    logic do
      source.where('client_applications.assigned_worker_id' => meta[:current_user].id)
    end
  end

  filter('Program') do
    require
    key :program
    on :data
    input(:multiple) { Program.all.map(&:to_s) }

    logic do
      client_application.program.to_s == input
    end
  end
end





class Sandbox
  def initialize(methods)
    @values = {}

    methods.map do |key, value|
      define(key, value)
    end
  end

  def build(base, block)
    @values[base] = instance_eval(&block)
    self
  end

  def [](key)
    @values[key]
  end

  def []=(key, value)
    if value.is_a?(Proc)
      @values[key] ||= value.call
    else
      @values[key] ||= value
    end
  end

  def define(key, value)
    self.class.class_eval do
      define_method(key) do
        self[key] = value
      end
    end
  end
end

RubyReportable.reports[:test].run(:meta => {:current_user => nil}, :input => {:program => 'Community Choices'})
